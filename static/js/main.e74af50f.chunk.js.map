{"version":3,"sources":["context/ChatContext.js","context/ChannelContext.js","context/TranslationContext.js","components/ChannelHeader/ChannelHeader.js","GetStream/utils.js","components/CustomChannelList/CustomChannelList.js","App.js","serviceWorker.js","index.js"],"names":["React","createContext","client","StreamChat","setActiveChannel","Dayjs","extend","LocalizedFormat","TranslationContext","t","key","tDateTimeParser","input","memo","title","live","useContext","ChannelContext","channel","watcher_count","openMobileNav","ChatContext","className","onClick","data","image","shape","size","type","name","subtitle","member_count","memberCount","watcherCount","emojiSetDef","spriteUrl","sheetColumns","sheetRows","sheetSize","commonEmoji","emoticons","short_names","custom","d","id","colons","sheet_x","sheet_y","Object","assign","emojis","CustomChannelList","chatClient","setUser","App","props","state","console","log","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e74af50f.chunk.js","sourcesContent":["// @ts-check\nimport React from 'react';\nimport { StreamChat } from 'stream-chat';\n\n/**\n * @typedef {import('../GetStream/types').ChatContextValue} ChatContextProps\n */\n\nexport const ChatContext = React.createContext(\n  /** @type {ChatContextProps} */({\n    client: new StreamChat(''),\n    setActiveChannel: () => null,\n  }),\n);\n\n/**\n * @function\n * @template P\n * @param {React.ComponentType<P>} OriginalComponent\n * @returns {React.ComponentType<Exclude<P, ChatContextProps>>}\n */\nexport function withChatContext(OriginalComponent) {\n  /** @param {Exclude<P, ChatContextProps>} props */\n  const ContextAwareComponent = function ContextComponent(props) {\n    return (\n      <ChatContext.Consumer>\n        {(context) => <OriginalComponent {...context} {...props} />}\n      </ChatContext.Consumer>\n    );\n  };\n\n  ContextAwareComponent.displayName = (\n    OriginalComponent.displayName ||\n    OriginalComponent.name ||\n    'Component'\n  ).replace('Base', '');\n\n  return ContextAwareComponent;\n}\n","// @ts-check\n\nimport React from 'react';\n\n/**\n * @typedef {import('../GetStream/types').ChannelContextValue} ChannelContextProps\n */\n\nexport const ChannelContext = React.createContext(\n  /** @type {ChannelContextProps} */({}),\n);\n\n/**\n * @function\n * @template P\n * @param { React.ComponentType<P> } OriginalComponent\n * @returns {React.ComponentType<Exclude<P, ChannelContextProps>>}\n */\nexport function withChannelContext(OriginalComponent) {\n  /** @param {Exclude<P, ChannelContextProps>} props */\n  const ContextAwareComponent = function ContextComponent(props) {\n    return (\n      <ChannelContext.Consumer>\n        {(context) => <OriginalComponent {...context} {...props} />}\n      </ChannelContext.Consumer>\n    );\n  };\n\n  ContextAwareComponent.displayName = (\n    OriginalComponent.displayName ||\n    OriginalComponent.name ||\n    'Component'\n  ).replace('Base', '');\n\n  return ContextAwareComponent;\n}\n","// @ts-check\n\nimport React from 'react';\nimport Dayjs from 'dayjs';\nimport LocalizedFormat from 'dayjs/plugin/localizedFormat';\n\nDayjs.extend(LocalizedFormat);\n\n/**\n * @typedef {Required<import('../GetStream/types').TranslationContextValue>} TranslationContextProps\n */\n\nexport const TranslationContext = React.createContext(\n  /** @type {TranslationContextProps} */({\n    t: /** @param {string} key */ (key) => key,\n    tDateTimeParser: (input) => Dayjs(input),\n  }),\n);\n\n/**\n * @function\n * @template P\n * @param {React.ComponentType<P>} OriginalComponent\n * @returns {React.ComponentType<Exclude<P, TranslationContextProps>>}\n */\nexport function withTranslationContext(OriginalComponent) {\n  /** @param {Exclude<P, TranslationContextProps>} props */\n  const ContextAwareComponent = function ContextComponent(props) {\n    return (\n      <TranslationContext.Consumer>\n        {(context) => <OriginalComponent {...context} {...props} />}\n      </TranslationContext.Consumer>\n    );\n  };\n\n  ContextAwareComponent.displayName = (\n    OriginalComponent.displayName ||\n    OriginalComponent.name ||\n    'Component'\n  ).replace('Base', '');\n\n  return ContextAwareComponent;\n}\n","// @ts-nocheck\n/*eslint-disable */\nimport React, { useContext } from 'react';\nimport PropTypes from 'prop-types';\n// import { ChannelContext, TranslationContext, ChatContext } from '../../context';\nimport { Avatar, ChannelContext, ChatContext } from 'stream-chat-react';\nimport { TranslationContext } from '../../context';\n\n/**\n * ChannelHeader - Render some basic information about this channel\n\n * @type {React.FC<import('../../GetStream/types').ChannelHeaderProps>}\n */\nconst ChannelHeader = ({ title, live }) => {\n    /** @type {import(\"../../GetStream/types\").TranslationContextValue} */\n    const { t } = useContext(TranslationContext);\n    /** @type {import(\"../../GetStream/types\").ChannelContextValue} */\n    const { channel, watcher_count } = useContext(ChannelContext);\n    const { openMobileNav } = useContext(ChatContext);\n\n    return (\n        <div className=\"str-chat__header-livestream\">\n            <div className=\"str-chat__header-hamburger\" onClick={openMobileNav}>\n                <span className=\"str-chat__header-hamburger--line\"></span>\n                <span className=\"str-chat__header-hamburger--line\"></span>\n                <span className=\"str-chat__header-hamburger--line\"></span>\n            </div>\n            {channel && channel.data.image && (\n                <Avatar\n                    image={channel.data.image}\n                    shape=\"rounded\"\n                    size={channel.type === 'commerce' ? 60 : 40}\n                />\n            )}\n            <div className=\"str-chat__header-livestream-left\">\n                <p className=\"str-chat__header-livestream-left--title\">\n                    {title || (channel && channel.data.name)}{' '}\n                    {live && (\n                        <span className=\"str-chat__header-livestream-left--livelabel\">\n                            {t('live')}\n                        </span>\n                    )}\n                </p>\n                {channel && channel.data.subtitle && (\n                    <p className=\"str-chat__header-livestream-left--subtitle\">\n                        {channel.data.subtitle}\n                    </p>\n                )}\n                <p className=\"str-chat__header-livestream-left--members\">\n                    {!live &&\n                        channel &&\n                        channel.data.member_count &&\n                        channel.data.member_count > 0 && (\n                            <>\n                                {t('{{ memberCount }} members', {\n                                    memberCount: channel.data.member_count,\n                                })}\n                ,{' '}\n                            </>\n                        )}\n                    {t('{{ watcherCount }} online', { watcherCount: watcher_count })}\n                </p>\n            </div>\n        </div>\n    );\n};\n\nChannelHeader.propTypes = {\n    /** Set title manually */\n    title: PropTypes.string,\n    /** Show a little indicator that the channel is live right now */\n    live: PropTypes.bool,\n};\n\nexport default React.memo(ChannelHeader);\n","/* eslint-disable */\nimport emojiRegex from 'emoji-regex';\nimport ReactMarkdown from 'react-markdown/with-html';\nimport data from 'emoji-mart/data/all.json';\nimport React from 'react';\nimport { find as linkifyFind } from 'linkifyjs/lib/linkify';\n\nexport const emojiSetDef = {\n  spriteUrl: 'https://getstream.imgix.net/images/emoji-sprite.png',\n  size: 20,\n  sheetColumns: 2,\n  sheetRows: 3,\n  sheetSize: 64,\n};\n\nexport const commonEmoji = {\n  emoticons: [],\n  short_names: [],\n  custom: true,\n};\n/** @type {import(\"types\").MinimalEmojiInterface[]} */\nexport const defaultMinimalEmojis = [\n  {\n    id: 'like',\n    name: 'like',\n    colons: ':+1:',\n    sheet_x: 0,\n    sheet_y: 0,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n  {\n    id: 'love',\n    name: 'love',\n    colons: ':heart:',\n    sheet_x: 1,\n    sheet_y: 2,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n  {\n    id: 'haha',\n    name: 'haha',\n    colons: ':joy:',\n    sheet_x: 1,\n    sheet_y: 0,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n  {\n    id: 'wow',\n    name: 'wow',\n    colons: ':astonished:',\n    sheet_x: 0,\n    sheet_y: 2,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n  {\n    id: 'sad',\n    name: 'sad',\n    colons: ':pensive:',\n    sheet_x: 0,\n    sheet_y: 1,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n  {\n    id: 'angry',\n    name: 'angry',\n    colons: ':angry:',\n    sheet_x: 1,\n    sheet_y: 1,\n    ...commonEmoji,\n    ...emojiSetDef,\n  },\n];\n\nconst d = Object.assign({}, data);\nd.emojis = {};\n\n// use this only for small lists like in ReactionSelector\nexport const emojiData = d;\n\nexport const isOnlyEmojis = (text) => {\n  if (!text) return false;\n\n  const noEmojis = text.replace(emojiRegex(), '');\n  const noSpace = noEmojis.replace(/[\\s\\n]/gm, '');\n  return !noSpace;\n};\n\nexport const isPromise = (thing) => thing && typeof thing.then === 'function';\n\nexport const byDate = (a, b) => a.created_at - b.created_at;\n\n// https://stackoverflow.com/a/29234240/7625485\n/**\n * @deprecated This function is deprecated and will be removed in future major release.\n * @param {*} dict\n * @param {*} currentUserId\n */\nexport const formatArray = (dict, currentUserId) => {\n  const arr2 = Object.keys(dict);\n  const arr3 = [];\n  arr2.forEach((item, i) => {\n    if (currentUserId === dict[arr2[i]].user.id) {\n      return;\n    }\n\n    arr3.push(dict[arr2[i]].user.name || dict[arr2[i]].user.id);\n  });\n  let outStr = '';\n  if (arr3.length === 1) {\n    outStr = arr3[0] + ' is typing...';\n    dict;\n  } else if (arr3.length === 2) {\n    //joins all with \"and\" but =no commas\n    //example: \"bob and sam\"\n    outStr = arr3.join(' and ') + ' are typing...';\n  } else if (arr3.length > 2) {\n    //joins all with commas, but last one gets \", and\" (oxford comma!)\n    //example: \"bob, joe, and sam\"\n    outStr =\n      arr3.slice(0, -1).join(', ') +\n      ', and ' +\n      arr3.slice(-1) +\n      ' are typing...';\n  }\n\n  return outStr;\n};\n\nconst allowedMarkups = [\n  'html',\n  'root',\n  'text',\n  'break',\n  'paragraph',\n  'emphasis',\n  'strong',\n  'link',\n  'list',\n  'listItem',\n  'code',\n  'inlineCode',\n  'blockquote',\n  'delete',\n];\n\nconst matchMarkdownLinks = (message) => {\n  const regexMdLinks = /\\[([^\\[]+)\\](\\(.*\\))/gm;\n  const matches = message.match(regexMdLinks);\n  const singleMatch = /\\[([^\\[]+)\\]\\((.*)\\)/;\n\n  const links = matches\n    ? matches.map((match) => singleMatch.exec(match)[2])\n    : [];\n  return links;\n};\n\nexport const truncate = (input, length, end = '...') => {\n  if (input.length > length) {\n    return `${input.substring(0, length - end.length)}${end}`;\n  }\n  return input;\n};\n\nexport const renderText = (text, mentioned_users) => {\n  // take the @ mentions and turn them into markdown?\n  // translate links\n  if (!text) return null;\n\n  let newText = text;\n  let markdownLinks = matchMarkdownLinks(newText);\n  // extract all valid links/emails within text and replace it with proper markup\n  linkifyFind(newText).forEach(({ type, href, value }) => {\n    // check if message is already  markdown\n    const noParsingNeeded =\n      markdownLinks &&\n      markdownLinks.filter((text) => text.indexOf(href) !== -1);\n    if (noParsingNeeded.length > 0) return;\n\n    const displayLink =\n      type === 'email'\n        ? value\n        : truncate(value.replace(/(http(s?):\\/\\/)?(www\\.)?/, ''), 20);\n    newText = newText.replace(value, `[${displayLink}](${encodeURI(href)})`);\n  });\n\n  if (mentioned_users && mentioned_users.length) {\n    for (let i = 0;i < mentioned_users.length;i++) {\n      const username = mentioned_users[i].name || mentioned_users[i].id;\n      const mkdown = `**@${username}**`;\n      const re = new RegExp(`@${username}`, 'g');\n      newText = newText.replace(re, mkdown);\n    }\n  }\n\n  return (\n    <ReactMarkdown\n      allowedTypes={allowedMarkups}\n      source={newText}\n      linkTarget=\"_blank\"\n      plugins={[]}\n      escapeHtml={true}\n      skipHtml={false}\n      unwrapDisallowed={true}\n      transformLinkUri={(uri) => {\n        if (uri.startsWith('app://')) {\n          return uri;\n        } else {\n          return ReactMarkdown.uriTransformer(uri);\n        }\n      }}\n    />\n  );\n};\n\n// https://stackoverflow.com/a/6860916/2570866\nexport function generateRandomId() {\n  // prettier-ignore\n  return (S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4());\n}\n\nfunction S4() {\n  return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n}\n\nexport const smartRender = (ElementOrComponentOrLiteral, props, fallback) => {\n  if (ElementOrComponentOrLiteral === undefined) {\n    ElementOrComponentOrLiteral = fallback;\n  }\n  if (React.isValidElement(ElementOrComponentOrLiteral)) {\n    // Flow cast through any, to make flow believe it's a React.Element\n    const element = ElementOrComponentOrLiteral; // eslint-disable-line\n    return element;\n  }\n\n  // Flow cast through any to remove React.Element after previous check\n  const ComponentOrLiteral = ElementOrComponentOrLiteral;\n\n  if (\n    typeof ComponentOrLiteral === 'string' ||\n    typeof ComponentOrLiteral === 'number' ||\n    typeof ComponentOrLiteral === 'boolean' ||\n    ComponentOrLiteral == null\n  ) {\n    return ComponentOrLiteral;\n  }\n  return <ComponentOrLiteral {...props} />;\n};\n\nexport const filterEmoji = (emoji) => {\n  if (\n    emoji.name === 'White Smiling Face' ||\n    emoji.name === 'White Frowning Face'\n  ) {\n    return false;\n  }\n  return true;\n};\n\nexport const getReadByTooltipText = (users, t, client) => {\n  let outStr = '';\n  // first filter out client user, so restLength won't count it\n  const otherUsers = users\n    .filter((item) => item && item.id !== client.user.id)\n    .map((item) => item.name || item.id);\n\n  const slicedArr = otherUsers.slice(0, 5);\n  const restLength = otherUsers.length - slicedArr.length;\n\n  if (slicedArr.length === 1) {\n    outStr = slicedArr[0] + ' ';\n  } else if (slicedArr.length === 2) {\n    //joins all with \"and\" but =no commas\n    //example: \"bob and sam\"\n    outStr = t('{{ firstUser }} and {{ secondUser }}', {\n      firstUser: slicedArr[0],\n      secondUser: slicedArr[1],\n    });\n  } else if (slicedArr.length > 2) {\n    //joins all with commas, but last one gets \", and\" (oxford comma!)\n    //example: \"bob, joe, sam and 4 more\"\n    if (restLength === 0) {\n      // mutate slicedArr to remove last user to display it separately\n      const lastUser = slicedArr.splice(slicedArr.length - 2, 1);\n      outStr = t('{{ commaSeparatedUsers }}, and {{ lastUser }}', {\n        commaSeparatedUsers: slicedArr.join(', '),\n        lastUser,\n      });\n    } else {\n      outStr = t('{{ commaSeparatedUsers }} and {{ moreCount }} more', {\n        commaSeparatedUsers: slicedArr.join(', '),\n        moreCount: restLength,\n      });\n    }\n  }\n\n  return outStr;\n};\n","import React, { Component, useRef } from 'react';\nimport { truncate } from '../../GetStream/utils';\nimport { Avatar } from 'stream-chat-react';\nimport ReactDOM from \"react-dom\";\n// import ChatIcons from './IconsForChannelList'\n// import '../chatPage.css'\n// const rootElement = document.getElementById(\"root\");\n// ReactDOM.render(<ChatIcons />, rootElement);\n\nfunction CustomChannelList(props) {\n    const channelPreviewButton = useRef(null);\n    const onSelectChannel = () => {\n        props.setActiveChannel(props.channel, props.watchers);\n        // eslint-disable-next-line no-unused-expressions\n        channelPreviewButton?.current?.blur();\n    };\n    const unreadClass =\n        props.unread >= 1 ? 'str-chat__channel-preview--unread' : '';\n    const activeClass = props.active ? 'str-chat__channel-preview--active' : '';\n    return (\n\n            <div className=\"listOfChannels\">\n                <div className={`str-chat__channel-preview ${unreadClass} ${activeClass}`}>\n                    <button\n                        onClick={onSelectChannel}\n                        ref={channelPreviewButton}\n                        data-testid=\"channel-preview-button\"\n                    >\n                        {props.unread >= 1 && (\n                            <div className=\"str-chat__channel-preview--dot\" />\n                        )}\n                        <Avatar image={props.displayImage} />\n                        <div className=\"str-chat__channel-preview-info\">\n                            <span className=\"str-chat__channel-preview-title\">\n                                {props.displayTitle}\n                            </span>\n                            <span className=\"str-chat__channel-preview-last-message\">\n                                {truncate(props.latestMessage, props.latestMessageLength)}\n                            </span>\n                            {props.unread >= 1 && (\n                                <span className=\"str-chat__channel-preview-unread-count\">\n                                    {props.unread}\n                                </span>\n                            )}\n                        </div>\n                    </button>\n                </div>\n            </div>\n\n\n    );\n}\n\nexport default CustomChannelList\n","import React, { Component } from 'react';\nimport {\n  Chat,\n  Channel,\n  ChannelListMessenger,\n  MessageInput,\n  ChannelList,\n  MessageList,\n  Window,\n  Thread\n} from 'stream-chat-react';\nimport 'stream-chat-react/dist/css/index.css';\nimport { StreamChat } from 'stream-chat';\n// import ChatIcons from './CustomChannelList/IconsForChannelList';\nimport ChatMessageArea from './components/ChatMessageArea/ChatMessageArea';\nimport ChannelListTeam from './components/ChannelListTeam/ChannelListTeam';\n\nimport Community from './components/Community/Community';\n\nimport CustomChannelList from './components/CustomChannelList/CustomChannelList';\n\n\n\n\nconst chatClient = new StreamChat('gx5a64bj4ptz');\nconst userToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoic29mdC13aW5kLTkifQ.XeJKpCkb_zEMI8VGFObjTTwGEltL-ay0tmLgmWPw5cg';\n\nchatClient.setUser(\n  {\n       id: 'soft-wind-9',\n       name: 'Soft wind',\n       image: 'https://getstream.io/random_png/?id=soft-wind-9&name=Soft+wind'\n  },\n  userToken,\n);\n\nconst channel = chatClient.channel('messaging', 'godevs', {\n  // add as many custom fields as you'd like\n  image: 'https://cdn.chrisshort.net/testing-certificate-chains-in-go/GOPHER_MIC_DROP.png',\n  name: 'Talk about Go',\n});\n\n\n\nexport default class App extends Component{\n    constructor(props){\n      super(props);\n\n\n      this.state = {\n\n      }\n    }\n\n\n\n\n    componentDidMount(){\n\n      // fetch data here\n      // .then()\n\n    }\n\n\n\n\n\nrender () {\n  const filters = { type: 'messaging', members: { $in: ['wispy-wildflower-1'] } };\n\n\n\n  console.log('chat clients', chatClient)\n  return (\n    // this.state.isUserLoggedIn === 'user logged' ? {\n      // chat window\n    // }\n    // : else\n    // {\n          // user not logged in <LogIn />\n    // }\n\n    <Chat client={chatClient} theme={'messaging dark'}>\n    {// <Sidebar/>\n    }\n\n\n      <ChannelList\n          filters={filters}\n          List={ChannelListTeam}\n          // List={Community}\n          // Preview={CustomChannelList}\n\n      />\n\n      <ChatMessageArea />\n    </Chat>\n  )\n}\n}\n\n\n\n\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App.js';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}